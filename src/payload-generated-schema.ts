/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run `payload generate:db-schema` to regenerate this file.
 */

import {
  pgTable,
  index,
  uniqueIndex,
  foreignKey,
  serial,
  varchar,
  jsonb,
  timestamp,
  numeric,
  integer,
  type AnyPgColumn,
  boolean,
  pgEnum,
} from '@payloadcms/db-postgres/drizzle/pg-core';
import { sql, relations } from '@payloadcms/db-postgres/drizzle';
export const enum_users_roles = pgEnum('enum_users_roles', ['admin', 'editor']);
export const enum_trainings_status = pgEnum('enum_trainings_status', [
  'ongoing',
  'not-started',
  'completed',
  'on-hold',
]);

export const media = pgTable(
  'media',
  {
    id: serial('id').primaryKey(),
    alt: varchar('alt'),
    caption: jsonb('caption'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    url: varchar('url'),
    thumbnailURL: varchar('thumbnail_u_r_l'),
    filename: varchar('filename'),
    mimeType: varchar('mime_type'),
    filesize: numeric('filesize'),
    width: numeric('width'),
    height: numeric('height'),
    focalX: numeric('focal_x'),
    focalY: numeric('focal_y'),
    sizes_thumbnail_url: varchar('sizes_thumbnail_url'),
    sizes_thumbnail_width: numeric('sizes_thumbnail_width'),
    sizes_thumbnail_height: numeric('sizes_thumbnail_height'),
    sizes_thumbnail_mimeType: varchar('sizes_thumbnail_mime_type'),
    sizes_thumbnail_filesize: numeric('sizes_thumbnail_filesize'),
    sizes_thumbnail_filename: varchar('sizes_thumbnail_filename'),
    sizes_square_url: varchar('sizes_square_url'),
    sizes_square_width: numeric('sizes_square_width'),
    sizes_square_height: numeric('sizes_square_height'),
    sizes_square_mimeType: varchar('sizes_square_mime_type'),
    sizes_square_filesize: numeric('sizes_square_filesize'),
    sizes_square_filename: varchar('sizes_square_filename'),
    sizes_small_url: varchar('sizes_small_url'),
    sizes_small_width: numeric('sizes_small_width'),
    sizes_small_height: numeric('sizes_small_height'),
    sizes_small_mimeType: varchar('sizes_small_mime_type'),
    sizes_small_filesize: numeric('sizes_small_filesize'),
    sizes_small_filename: varchar('sizes_small_filename'),
    sizes_medium_url: varchar('sizes_medium_url'),
    sizes_medium_width: numeric('sizes_medium_width'),
    sizes_medium_height: numeric('sizes_medium_height'),
    sizes_medium_mimeType: varchar('sizes_medium_mime_type'),
    sizes_medium_filesize: numeric('sizes_medium_filesize'),
    sizes_medium_filename: varchar('sizes_medium_filename'),
    sizes_large_url: varchar('sizes_large_url'),
    sizes_large_width: numeric('sizes_large_width'),
    sizes_large_height: numeric('sizes_large_height'),
    sizes_large_mimeType: varchar('sizes_large_mime_type'),
    sizes_large_filesize: numeric('sizes_large_filesize'),
    sizes_large_filename: varchar('sizes_large_filename'),
    sizes_xlarge_url: varchar('sizes_xlarge_url'),
    sizes_xlarge_width: numeric('sizes_xlarge_width'),
    sizes_xlarge_height: numeric('sizes_xlarge_height'),
    sizes_xlarge_mimeType: varchar('sizes_xlarge_mime_type'),
    sizes_xlarge_filesize: numeric('sizes_xlarge_filesize'),
    sizes_xlarge_filename: varchar('sizes_xlarge_filename'),
    sizes_og_url: varchar('sizes_og_url'),
    sizes_og_width: numeric('sizes_og_width'),
    sizes_og_height: numeric('sizes_og_height'),
    sizes_og_mimeType: varchar('sizes_og_mime_type'),
    sizes_og_filesize: numeric('sizes_og_filesize'),
    sizes_og_filename: varchar('sizes_og_filename'),
  },
  (columns) => ({
    media_updated_at_idx: index('media_updated_at_idx').on(columns.updatedAt),
    media_created_at_idx: index('media_created_at_idx').on(columns.createdAt),
    media_filename_idx: uniqueIndex('media_filename_idx').on(columns.filename),
    media_sizes_thumbnail_sizes_thumbnail_filename_idx: index(
      'media_sizes_thumbnail_sizes_thumbnail_filename_idx',
    ).on(columns.sizes_thumbnail_filename),
    media_sizes_square_sizes_square_filename_idx: index(
      'media_sizes_square_sizes_square_filename_idx',
    ).on(columns.sizes_square_filename),
    media_sizes_small_sizes_small_filename_idx: index(
      'media_sizes_small_sizes_small_filename_idx',
    ).on(columns.sizes_small_filename),
    media_sizes_medium_sizes_medium_filename_idx: index(
      'media_sizes_medium_sizes_medium_filename_idx',
    ).on(columns.sizes_medium_filename),
    media_sizes_large_sizes_large_filename_idx: index(
      'media_sizes_large_sizes_large_filename_idx',
    ).on(columns.sizes_large_filename),
    media_sizes_xlarge_sizes_xlarge_filename_idx: index(
      'media_sizes_xlarge_sizes_xlarge_filename_idx',
    ).on(columns.sizes_xlarge_filename),
    media_sizes_og_sizes_og_filename_idx: index('media_sizes_og_sizes_og_filename_idx').on(
      columns.sizes_og_filename,
    ),
  }),
);

export const categories_breadcrumbs = pgTable(
  'categories_breadcrumbs',
  {
    _order: integer('_order').notNull(),
    _parentID: integer('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    doc: integer('doc_id').references(() => categories.id, {
      onDelete: 'set null',
    }),
    url: varchar('url'),
    label: varchar('label'),
  },
  (columns) => ({
    _orderIdx: index('categories_breadcrumbs_order_idx').on(columns._order),
    _parentIDIdx: index('categories_breadcrumbs_parent_id_idx').on(columns._parentID),
    categories_breadcrumbs_doc_idx: index('categories_breadcrumbs_doc_idx').on(columns.doc),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [categories.id],
      name: 'categories_breadcrumbs_parent_id_fk',
    }).onDelete('cascade'),
  }),
);

export const categories = pgTable(
  'categories',
  {
    id: serial('id').primaryKey(),
    title: varchar('title').notNull(),
    parent: integer('parent_id').references((): AnyPgColumn => categories.id, {
      onDelete: 'set null',
    }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    categories_parent_idx: index('categories_parent_idx').on(columns.parent),
    categories_updated_at_idx: index('categories_updated_at_idx').on(columns.updatedAt),
    categories_created_at_idx: index('categories_created_at_idx').on(columns.createdAt),
  }),
);

export const users_roles = pgTable(
  'users_roles',
  {
    order: integer('order').notNull(),
    parent: integer('parent_id').notNull(),
    value: enum_users_roles('value'),
    id: serial('id').primaryKey(),
  },
  (columns) => ({
    orderIdx: index('users_roles_order_idx').on(columns.order),
    parentIdx: index('users_roles_parent_idx').on(columns.parent),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [users.id],
      name: 'users_roles_parent_fk',
    }).onDelete('cascade'),
  }),
);

export const users = pgTable(
  'users',
  {
    id: serial('id').primaryKey(),
    name: varchar('name'),
    jobTitle: varchar('job_title'),
    profile: integer('profile_id').references(() => profiles.id, {
      onDelete: 'set null',
    }),
    reportTo: integer('report_to_id').references((): AnyPgColumn => users.id, {
      onDelete: 'set null',
    }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    email: varchar('email').notNull(),
    resetPasswordToken: varchar('reset_password_token'),
    resetPasswordExpiration: timestamp('reset_password_expiration', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    salt: varchar('salt'),
    hash: varchar('hash'),
    _verified: boolean('_verified'),
    _verificationToken: varchar('_verificationtoken'),
    loginAttempts: numeric('login_attempts').default('0'),
    lockUntil: timestamp('lock_until', { mode: 'string', withTimezone: true, precision: 3 }),
  },
  (columns) => ({
    users_profile_idx: index('users_profile_idx').on(columns.profile),
    users_report_to_idx: index('users_report_to_idx').on(columns.reportTo),
    users_updated_at_idx: index('users_updated_at_idx').on(columns.updatedAt),
    users_created_at_idx: index('users_created_at_idx').on(columns.createdAt),
    users_email_idx: uniqueIndex('users_email_idx').on(columns.email),
  }),
);

export const profiles = pgTable(
  'profiles',
  {
    id: serial('id').primaryKey(),
    firstName: varchar('first_name'),
    lastName: varchar('last_name'),
    avatar: integer('avatar_id').references(() => media.id, {
      onDelete: 'set null',
    }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    profiles_avatar_idx: index('profiles_avatar_idx').on(columns.avatar),
    profiles_updated_at_idx: index('profiles_updated_at_idx').on(columns.updatedAt),
    profiles_created_at_idx: index('profiles_created_at_idx').on(columns.createdAt),
  }),
);

export const certificates = pgTable(
  'certificates',
  {
    id: serial('id').primaryKey(),
    name: varchar('name').notNull(),
    issuingOrganization: varchar('issuing_organization').notNull(),
    deliveryDate: timestamp('delivery_date', { mode: 'string', withTimezone: true, precision: 3 }),
    expiryDate: timestamp('expiry_date', { mode: 'string', withTimezone: true, precision: 3 }),
    user: integer('user_id').references(() => users.id, {
      onDelete: 'set null',
    }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    certificates_user_idx: index('certificates_user_idx').on(columns.user),
    certificates_updated_at_idx: index('certificates_updated_at_idx').on(columns.updatedAt),
    certificates_created_at_idx: index('certificates_created_at_idx').on(columns.createdAt),
  }),
);

export const certificates_rels = pgTable(
  'certificates_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: integer('parent_id').notNull(),
    path: varchar('path').notNull(),
    users_skillsID: integer('users_skills_id'),
  },
  (columns) => ({
    order: index('certificates_rels_order_idx').on(columns.order),
    parentIdx: index('certificates_rels_parent_idx').on(columns.parent),
    pathIdx: index('certificates_rels_path_idx').on(columns.path),
    certificates_rels_users_skills_id_idx: index('certificates_rels_users_skills_id_idx').on(
      columns.users_skillsID,
    ),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [certificates.id],
      name: 'certificates_rels_parent_fk',
    }).onDelete('cascade'),
    users_skillsIdFk: foreignKey({
      columns: [columns['users_skillsID']],
      foreignColumns: [users_skills.id],
      name: 'certificates_rels_users_skills_fk',
    }).onDelete('cascade'),
  }),
);

export const skills = pgTable(
  'skills',
  {
    id: serial('id').primaryKey(),
    name: varchar('name').notNull(),
    description: varchar('description'),
    category: integer('category_id').references(() => categories.id, {
      onDelete: 'set null',
    }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    skills_category_idx: index('skills_category_idx').on(columns.category),
    skills_updated_at_idx: index('skills_updated_at_idx').on(columns.updatedAt),
    skills_created_at_idx: index('skills_created_at_idx').on(columns.createdAt),
  }),
);

export const users_skills = pgTable(
  'users_skills',
  {
    id: serial('id').primaryKey(),
    user: integer('user_id').references(() => users.id, {
      onDelete: 'set null',
    }),
    skill: integer('skill_id').references(() => skills.id, {
      onDelete: 'set null',
    }),
    currentLevel: numeric('current_level'),
    desiredLevel: numeric('desired_level'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    users_skills_user_idx: index('users_skills_user_idx').on(columns.user),
    users_skills_skill_idx: index('users_skills_skill_idx').on(columns.skill),
    users_skills_updated_at_idx: index('users_skills_updated_at_idx').on(columns.updatedAt),
    users_skills_created_at_idx: index('users_skills_created_at_idx').on(columns.createdAt),
  }),
);

export const teams = pgTable(
  'teams',
  {
    id: serial('id').primaryKey(),
    name: varchar('name').notNull(),
    description: varchar('description'),
    owner: integer('owner_id')
      .notNull()
      .references(() => users.id, {
        onDelete: 'set null',
      }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    teams_owner_idx: index('teams_owner_idx').on(columns.owner),
    teams_updated_at_idx: index('teams_updated_at_idx').on(columns.updatedAt),
    teams_created_at_idx: index('teams_created_at_idx').on(columns.createdAt),
  }),
);

export const teams_users = pgTable(
  'teams_users',
  {
    id: serial('id').primaryKey(),
    team: integer('team_id').references(() => teams.id, {
      onDelete: 'set null',
    }),
    user: integer('user_id').references(() => users.id, {
      onDelete: 'set null',
    }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    teams_users_team_idx: index('teams_users_team_idx').on(columns.team),
    teams_users_user_idx: index('teams_users_user_idx').on(columns.user),
    teams_users_updated_at_idx: index('teams_users_updated_at_idx').on(columns.updatedAt),
    teams_users_created_at_idx: index('teams_users_created_at_idx').on(columns.createdAt),
    userIdTeamId: uniqueIndex('userIdTeamIdUnique').on(columns.user, columns.team),
  }),
);

export const team_skills = pgTable(
  'team_skills',
  {
    id: serial('id').primaryKey(),
    team: integer('team_id').references(() => teams.id, {
      onDelete: 'set null',
    }),
    skill: integer('skill_id').references(() => skills.id, {
      onDelete: 'set null',
    }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    team_skills_team_idx: index('team_skills_team_idx').on(columns.team),
    team_skills_skill_idx: index('team_skills_skill_idx').on(columns.skill),
    team_skills_updated_at_idx: index('team_skills_updated_at_idx').on(columns.updatedAt),
    team_skills_created_at_idx: index('team_skills_created_at_idx').on(columns.createdAt),
  }),
);

export const team_requirements = pgTable(
  'team_requirements',
  {
    id: serial('id').primaryKey(),
    team: integer('team_id').references(() => teams.id, {
      onDelete: 'set null',
    }),
    skill: integer('skill_id').references(() => skills.id, {
      onDelete: 'set null',
    }),
    desiredLevel: numeric('desired_level'),
    desiredMembers: numeric('desired_members'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    team_requirements_team_idx: index('team_requirements_team_idx').on(columns.team),
    team_requirements_skill_idx: index('team_requirements_skill_idx').on(columns.skill),
    team_requirements_updated_at_idx: index('team_requirements_updated_at_idx').on(
      columns.updatedAt,
    ),
    team_requirements_created_at_idx: index('team_requirements_created_at_idx').on(
      columns.createdAt,
    ),
  }),
);

export const trainings = pgTable(
  'trainings',
  {
    id: serial('id').primaryKey(),
    name: varchar('name').notNull(),
    link: varchar('link'),
    description: varchar('description'),
    user: integer('user_id')
      .notNull()
      .references(() => users.id, {
        onDelete: 'set null',
      }),
    status: enum_trainings_status('status').default('not-started'),
    startDate: timestamp('start_date', { mode: 'string', withTimezone: true, precision: 3 }),
    endDate: timestamp('end_date', { mode: 'string', withTimezone: true, precision: 3 }),
    certificate: integer('certificate_id').references(() => certificates.id, {
      onDelete: 'set null',
    }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    trainings_user_idx: index('trainings_user_idx').on(columns.user),
    trainings_certificate_idx: index('trainings_certificate_idx').on(columns.certificate),
    trainings_updated_at_idx: index('trainings_updated_at_idx').on(columns.updatedAt),
    trainings_created_at_idx: index('trainings_created_at_idx').on(columns.createdAt),
  }),
);

export const trainings_rels = pgTable(
  'trainings_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: integer('parent_id').notNull(),
    path: varchar('path').notNull(),
    users_skillsID: integer('users_skills_id'),
  },
  (columns) => ({
    order: index('trainings_rels_order_idx').on(columns.order),
    parentIdx: index('trainings_rels_parent_idx').on(columns.parent),
    pathIdx: index('trainings_rels_path_idx').on(columns.path),
    trainings_rels_users_skills_id_idx: index('trainings_rels_users_skills_id_idx').on(
      columns.users_skillsID,
    ),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [trainings.id],
      name: 'trainings_rels_parent_fk',
    }).onDelete('cascade'),
    users_skillsIdFk: foreignKey({
      columns: [columns['users_skillsID']],
      foreignColumns: [users_skills.id],
      name: 'trainings_rels_users_skills_fk',
    }).onDelete('cascade'),
  }),
);

export const payload_locked_documents = pgTable(
  'payload_locked_documents',
  {
    id: serial('id').primaryKey(),
    globalSlug: varchar('global_slug'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_locked_documents_global_slug_idx: index('payload_locked_documents_global_slug_idx').on(
      columns.globalSlug,
    ),
    payload_locked_documents_updated_at_idx: index('payload_locked_documents_updated_at_idx').on(
      columns.updatedAt,
    ),
    payload_locked_documents_created_at_idx: index('payload_locked_documents_created_at_idx').on(
      columns.createdAt,
    ),
  }),
);

export const payload_locked_documents_rels = pgTable(
  'payload_locked_documents_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: integer('parent_id').notNull(),
    path: varchar('path').notNull(),
    mediaID: integer('media_id'),
    categoriesID: integer('categories_id'),
    usersID: integer('users_id'),
    profilesID: integer('profiles_id'),
    certificatesID: integer('certificates_id'),
    skillsID: integer('skills_id'),
    users_skillsID: integer('users_skills_id'),
    teamsID: integer('teams_id'),
    teams_usersID: integer('teams_users_id'),
    team_skillsID: integer('team_skills_id'),
    team_requirementsID: integer('team_requirements_id'),
    trainingsID: integer('trainings_id'),
  },
  (columns) => ({
    order: index('payload_locked_documents_rels_order_idx').on(columns.order),
    parentIdx: index('payload_locked_documents_rels_parent_idx').on(columns.parent),
    pathIdx: index('payload_locked_documents_rels_path_idx').on(columns.path),
    payload_locked_documents_rels_media_id_idx: index(
      'payload_locked_documents_rels_media_id_idx',
    ).on(columns.mediaID),
    payload_locked_documents_rels_categories_id_idx: index(
      'payload_locked_documents_rels_categories_id_idx',
    ).on(columns.categoriesID),
    payload_locked_documents_rels_users_id_idx: index(
      'payload_locked_documents_rels_users_id_idx',
    ).on(columns.usersID),
    payload_locked_documents_rels_profiles_id_idx: index(
      'payload_locked_documents_rels_profiles_id_idx',
    ).on(columns.profilesID),
    payload_locked_documents_rels_certificates_id_idx: index(
      'payload_locked_documents_rels_certificates_id_idx',
    ).on(columns.certificatesID),
    payload_locked_documents_rels_skills_id_idx: index(
      'payload_locked_documents_rels_skills_id_idx',
    ).on(columns.skillsID),
    payload_locked_documents_rels_users_skills_id_idx: index(
      'payload_locked_documents_rels_users_skills_id_idx',
    ).on(columns.users_skillsID),
    payload_locked_documents_rels_teams_id_idx: index(
      'payload_locked_documents_rels_teams_id_idx',
    ).on(columns.teamsID),
    payload_locked_documents_rels_teams_users_id_idx: index(
      'payload_locked_documents_rels_teams_users_id_idx',
    ).on(columns.teams_usersID),
    payload_locked_documents_rels_team_skills_id_idx: index(
      'payload_locked_documents_rels_team_skills_id_idx',
    ).on(columns.team_skillsID),
    payload_locked_documents_rels_team_requirements_id_idx: index(
      'payload_locked_documents_rels_team_requirements_id_idx',
    ).on(columns.team_requirementsID),
    payload_locked_documents_rels_trainings_id_idx: index(
      'payload_locked_documents_rels_trainings_id_idx',
    ).on(columns.trainingsID),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [payload_locked_documents.id],
      name: 'payload_locked_documents_rels_parent_fk',
    }).onDelete('cascade'),
    mediaIdFk: foreignKey({
      columns: [columns['mediaID']],
      foreignColumns: [media.id],
      name: 'payload_locked_documents_rels_media_fk',
    }).onDelete('cascade'),
    categoriesIdFk: foreignKey({
      columns: [columns['categoriesID']],
      foreignColumns: [categories.id],
      name: 'payload_locked_documents_rels_categories_fk',
    }).onDelete('cascade'),
    usersIdFk: foreignKey({
      columns: [columns['usersID']],
      foreignColumns: [users.id],
      name: 'payload_locked_documents_rels_users_fk',
    }).onDelete('cascade'),
    profilesIdFk: foreignKey({
      columns: [columns['profilesID']],
      foreignColumns: [profiles.id],
      name: 'payload_locked_documents_rels_profiles_fk',
    }).onDelete('cascade'),
    certificatesIdFk: foreignKey({
      columns: [columns['certificatesID']],
      foreignColumns: [certificates.id],
      name: 'payload_locked_documents_rels_certificates_fk',
    }).onDelete('cascade'),
    skillsIdFk: foreignKey({
      columns: [columns['skillsID']],
      foreignColumns: [skills.id],
      name: 'payload_locked_documents_rels_skills_fk',
    }).onDelete('cascade'),
    users_skillsIdFk: foreignKey({
      columns: [columns['users_skillsID']],
      foreignColumns: [users_skills.id],
      name: 'payload_locked_documents_rels_users_skills_fk',
    }).onDelete('cascade'),
    teamsIdFk: foreignKey({
      columns: [columns['teamsID']],
      foreignColumns: [teams.id],
      name: 'payload_locked_documents_rels_teams_fk',
    }).onDelete('cascade'),
    teams_usersIdFk: foreignKey({
      columns: [columns['teams_usersID']],
      foreignColumns: [teams_users.id],
      name: 'payload_locked_documents_rels_teams_users_fk',
    }).onDelete('cascade'),
    team_skillsIdFk: foreignKey({
      columns: [columns['team_skillsID']],
      foreignColumns: [team_skills.id],
      name: 'payload_locked_documents_rels_team_skills_fk',
    }).onDelete('cascade'),
    team_requirementsIdFk: foreignKey({
      columns: [columns['team_requirementsID']],
      foreignColumns: [team_requirements.id],
      name: 'payload_locked_documents_rels_team_requirements_fk',
    }).onDelete('cascade'),
    trainingsIdFk: foreignKey({
      columns: [columns['trainingsID']],
      foreignColumns: [trainings.id],
      name: 'payload_locked_documents_rels_trainings_fk',
    }).onDelete('cascade'),
  }),
);

export const payload_preferences = pgTable(
  'payload_preferences',
  {
    id: serial('id').primaryKey(),
    key: varchar('key'),
    value: jsonb('value'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_preferences_key_idx: index('payload_preferences_key_idx').on(columns.key),
    payload_preferences_updated_at_idx: index('payload_preferences_updated_at_idx').on(
      columns.updatedAt,
    ),
    payload_preferences_created_at_idx: index('payload_preferences_created_at_idx').on(
      columns.createdAt,
    ),
  }),
);

export const payload_preferences_rels = pgTable(
  'payload_preferences_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: integer('parent_id').notNull(),
    path: varchar('path').notNull(),
    usersID: integer('users_id'),
  },
  (columns) => ({
    order: index('payload_preferences_rels_order_idx').on(columns.order),
    parentIdx: index('payload_preferences_rels_parent_idx').on(columns.parent),
    pathIdx: index('payload_preferences_rels_path_idx').on(columns.path),
    payload_preferences_rels_users_id_idx: index('payload_preferences_rels_users_id_idx').on(
      columns.usersID,
    ),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [payload_preferences.id],
      name: 'payload_preferences_rels_parent_fk',
    }).onDelete('cascade'),
    usersIdFk: foreignKey({
      columns: [columns['usersID']],
      foreignColumns: [users.id],
      name: 'payload_preferences_rels_users_fk',
    }).onDelete('cascade'),
  }),
);

export const payload_migrations = pgTable(
  'payload_migrations',
  {
    id: serial('id').primaryKey(),
    name: varchar('name'),
    batch: numeric('batch'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_migrations_updated_at_idx: index('payload_migrations_updated_at_idx').on(
      columns.updatedAt,
    ),
    payload_migrations_created_at_idx: index('payload_migrations_created_at_idx').on(
      columns.createdAt,
    ),
  }),
);

export const levels_items = pgTable(
  'levels_items',
  {
    _order: integer('_order').notNull(),
    _parentID: integer('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    name: varchar('name').notNull(),
    description: varchar('description').notNull(),
    level: numeric('level').notNull(),
    levelColor: varchar('level_color').notNull(),
  },
  (columns) => ({
    _orderIdx: index('levels_items_order_idx').on(columns._order),
    _parentIDIdx: index('levels_items_parent_id_idx').on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [levels.id],
      name: 'levels_items_parent_id_fk',
    }).onDelete('cascade'),
  }),
);

export const levels = pgTable('levels', {
  id: serial('id').primaryKey(),
  updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 }),
  createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 }),
});

export const relations_media = relations(media, () => ({}));
export const relations_categories_breadcrumbs = relations(categories_breadcrumbs, ({ one }) => ({
  _parentID: one(categories, {
    fields: [categories_breadcrumbs._parentID],
    references: [categories.id],
    relationName: 'breadcrumbs',
  }),
  doc: one(categories, {
    fields: [categories_breadcrumbs.doc],
    references: [categories.id],
    relationName: 'doc',
  }),
}));
export const relations_categories = relations(categories, ({ one, many }) => ({
  parent: one(categories, {
    fields: [categories.parent],
    references: [categories.id],
    relationName: 'parent',
  }),
  breadcrumbs: many(categories_breadcrumbs, {
    relationName: 'breadcrumbs',
  }),
}));
export const relations_users_roles = relations(users_roles, ({ one }) => ({
  parent: one(users, {
    fields: [users_roles.parent],
    references: [users.id],
    relationName: 'roles',
  }),
}));
export const relations_users = relations(users, ({ one, many }) => ({
  roles: many(users_roles, {
    relationName: 'roles',
  }),
  profile: one(profiles, {
    fields: [users.profile],
    references: [profiles.id],
    relationName: 'profile',
  }),
  reportTo: one(users, {
    fields: [users.reportTo],
    references: [users.id],
    relationName: 'reportTo',
  }),
}));
export const relations_profiles = relations(profiles, ({ one }) => ({
  avatar: one(media, {
    fields: [profiles.avatar],
    references: [media.id],
    relationName: 'avatar',
  }),
}));
export const relations_certificates_rels = relations(certificates_rels, ({ one }) => ({
  parent: one(certificates, {
    fields: [certificates_rels.parent],
    references: [certificates.id],
    relationName: '_rels',
  }),
  users_skillsID: one(users_skills, {
    fields: [certificates_rels.users_skillsID],
    references: [users_skills.id],
    relationName: 'users_skills',
  }),
}));
export const relations_certificates = relations(certificates, ({ one, many }) => ({
  user: one(users, {
    fields: [certificates.user],
    references: [users.id],
    relationName: 'user',
  }),
  _rels: many(certificates_rels, {
    relationName: '_rels',
  }),
}));
export const relations_skills = relations(skills, ({ one }) => ({
  category: one(categories, {
    fields: [skills.category],
    references: [categories.id],
    relationName: 'category',
  }),
}));
export const relations_users_skills = relations(users_skills, ({ one }) => ({
  user: one(users, {
    fields: [users_skills.user],
    references: [users.id],
    relationName: 'user',
  }),
  skill: one(skills, {
    fields: [users_skills.skill],
    references: [skills.id],
    relationName: 'skill',
  }),
}));
export const relations_teams = relations(teams, ({ one }) => ({
  owner: one(users, {
    fields: [teams.owner],
    references: [users.id],
    relationName: 'owner',
  }),
}));
export const relations_teams_users = relations(teams_users, ({ one }) => ({
  team: one(teams, {
    fields: [teams_users.team],
    references: [teams.id],
    relationName: 'team',
  }),
  user: one(users, {
    fields: [teams_users.user],
    references: [users.id],
    relationName: 'user',
  }),
}));
export const relations_team_skills = relations(team_skills, ({ one }) => ({
  team: one(teams, {
    fields: [team_skills.team],
    references: [teams.id],
    relationName: 'team',
  }),
  skill: one(skills, {
    fields: [team_skills.skill],
    references: [skills.id],
    relationName: 'skill',
  }),
}));
export const relations_team_requirements = relations(team_requirements, ({ one }) => ({
  team: one(teams, {
    fields: [team_requirements.team],
    references: [teams.id],
    relationName: 'team',
  }),
  skill: one(skills, {
    fields: [team_requirements.skill],
    references: [skills.id],
    relationName: 'skill',
  }),
}));
export const relations_trainings_rels = relations(trainings_rels, ({ one }) => ({
  parent: one(trainings, {
    fields: [trainings_rels.parent],
    references: [trainings.id],
    relationName: '_rels',
  }),
  users_skillsID: one(users_skills, {
    fields: [trainings_rels.users_skillsID],
    references: [users_skills.id],
    relationName: 'users_skills',
  }),
}));
export const relations_trainings = relations(trainings, ({ one, many }) => ({
  user: one(users, {
    fields: [trainings.user],
    references: [users.id],
    relationName: 'user',
  }),
  certificate: one(certificates, {
    fields: [trainings.certificate],
    references: [certificates.id],
    relationName: 'certificate',
  }),
  _rels: many(trainings_rels, {
    relationName: '_rels',
  }),
}));
export const relations_payload_locked_documents_rels = relations(
  payload_locked_documents_rels,
  ({ one }) => ({
    parent: one(payload_locked_documents, {
      fields: [payload_locked_documents_rels.parent],
      references: [payload_locked_documents.id],
      relationName: '_rels',
    }),
    mediaID: one(media, {
      fields: [payload_locked_documents_rels.mediaID],
      references: [media.id],
      relationName: 'media',
    }),
    categoriesID: one(categories, {
      fields: [payload_locked_documents_rels.categoriesID],
      references: [categories.id],
      relationName: 'categories',
    }),
    usersID: one(users, {
      fields: [payload_locked_documents_rels.usersID],
      references: [users.id],
      relationName: 'users',
    }),
    profilesID: one(profiles, {
      fields: [payload_locked_documents_rels.profilesID],
      references: [profiles.id],
      relationName: 'profiles',
    }),
    certificatesID: one(certificates, {
      fields: [payload_locked_documents_rels.certificatesID],
      references: [certificates.id],
      relationName: 'certificates',
    }),
    skillsID: one(skills, {
      fields: [payload_locked_documents_rels.skillsID],
      references: [skills.id],
      relationName: 'skills',
    }),
    users_skillsID: one(users_skills, {
      fields: [payload_locked_documents_rels.users_skillsID],
      references: [users_skills.id],
      relationName: 'users_skills',
    }),
    teamsID: one(teams, {
      fields: [payload_locked_documents_rels.teamsID],
      references: [teams.id],
      relationName: 'teams',
    }),
    teams_usersID: one(teams_users, {
      fields: [payload_locked_documents_rels.teams_usersID],
      references: [teams_users.id],
      relationName: 'teams_users',
    }),
    team_skillsID: one(team_skills, {
      fields: [payload_locked_documents_rels.team_skillsID],
      references: [team_skills.id],
      relationName: 'team_skills',
    }),
    team_requirementsID: one(team_requirements, {
      fields: [payload_locked_documents_rels.team_requirementsID],
      references: [team_requirements.id],
      relationName: 'team_requirements',
    }),
    trainingsID: one(trainings, {
      fields: [payload_locked_documents_rels.trainingsID],
      references: [trainings.id],
      relationName: 'trainings',
    }),
  }),
);
export const relations_payload_locked_documents = relations(
  payload_locked_documents,
  ({ many }) => ({
    _rels: many(payload_locked_documents_rels, {
      relationName: '_rels',
    }),
  }),
);
export const relations_payload_preferences_rels = relations(
  payload_preferences_rels,
  ({ one }) => ({
    parent: one(payload_preferences, {
      fields: [payload_preferences_rels.parent],
      references: [payload_preferences.id],
      relationName: '_rels',
    }),
    usersID: one(users, {
      fields: [payload_preferences_rels.usersID],
      references: [users.id],
      relationName: 'users',
    }),
  }),
);
export const relations_payload_preferences = relations(payload_preferences, ({ many }) => ({
  _rels: many(payload_preferences_rels, {
    relationName: '_rels',
  }),
}));
export const relations_payload_migrations = relations(payload_migrations, () => ({}));
export const relations_levels_items = relations(levels_items, ({ one }) => ({
  _parentID: one(levels, {
    fields: [levels_items._parentID],
    references: [levels.id],
    relationName: 'items',
  }),
}));
export const relations_levels = relations(levels, ({ many }) => ({
  items: many(levels_items, {
    relationName: 'items',
  }),
}));

type DatabaseSchema = {
  enum_users_roles: typeof enum_users_roles;
  enum_trainings_status: typeof enum_trainings_status;
  media: typeof media;
  categories_breadcrumbs: typeof categories_breadcrumbs;
  categories: typeof categories;
  users_roles: typeof users_roles;
  users: typeof users;
  profiles: typeof profiles;
  certificates: typeof certificates;
  certificates_rels: typeof certificates_rels;
  skills: typeof skills;
  users_skills: typeof users_skills;
  teams: typeof teams;
  teams_users: typeof teams_users;
  team_skills: typeof team_skills;
  team_requirements: typeof team_requirements;
  trainings: typeof trainings;
  trainings_rels: typeof trainings_rels;
  payload_locked_documents: typeof payload_locked_documents;
  payload_locked_documents_rels: typeof payload_locked_documents_rels;
  payload_preferences: typeof payload_preferences;
  payload_preferences_rels: typeof payload_preferences_rels;
  payload_migrations: typeof payload_migrations;
  levels_items: typeof levels_items;
  levels: typeof levels;
  relations_media: typeof relations_media;
  relations_categories_breadcrumbs: typeof relations_categories_breadcrumbs;
  relations_categories: typeof relations_categories;
  relations_users_roles: typeof relations_users_roles;
  relations_users: typeof relations_users;
  relations_profiles: typeof relations_profiles;
  relations_certificates_rels: typeof relations_certificates_rels;
  relations_certificates: typeof relations_certificates;
  relations_skills: typeof relations_skills;
  relations_users_skills: typeof relations_users_skills;
  relations_teams: typeof relations_teams;
  relations_teams_users: typeof relations_teams_users;
  relations_team_skills: typeof relations_team_skills;
  relations_team_requirements: typeof relations_team_requirements;
  relations_trainings_rels: typeof relations_trainings_rels;
  relations_trainings: typeof relations_trainings;
  relations_payload_locked_documents_rels: typeof relations_payload_locked_documents_rels;
  relations_payload_locked_documents: typeof relations_payload_locked_documents;
  relations_payload_preferences_rels: typeof relations_payload_preferences_rels;
  relations_payload_preferences: typeof relations_payload_preferences;
  relations_payload_migrations: typeof relations_payload_migrations;
  relations_levels_items: typeof relations_levels_items;
  relations_levels: typeof relations_levels;
};

declare module '@payloadcms/db-postgres/types' {
  export interface GeneratedDatabaseSchema {
    schema: DatabaseSchema;
  }
}
